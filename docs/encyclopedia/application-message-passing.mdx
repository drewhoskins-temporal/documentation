---
id: workflow-message-passing
title: Temporal Workflow message passing - Signals, Queries, & Updates
sidebar_label: Workflow message passing
description: Signals, Queries, and Updates facilitate interactions with Workflow Executions.
tags:
- signals
- queries
- updates
- message-passing
keywords:
- temporal workflow signals
- temporal workflow queries
- temporal workflow updates
- temporal workflow execution
- message passing temporal
- signal-with-start temporal
- temporal query handler
- temporal update handler
- temporal message passing
- workflow state temporal
- synchronous operation temporal
- asynchronous request temporal
- temporal service events
- temporal client methods
- temporal sdk message passing
---

import { RelatedReadContainer, RelatedReadItem } from '@site/src/components/related-read/RelatedRead';

Workflows can be thought of as stateful web services that can receive messages. The Workflow can have powerful message handlers akin to endpoints that can react to the incoming messages in combination with the current state of the Workflow.
Temporal supports three types of messages: Signals, Queries, and Updates.
To define these, consider these messages from the perspective of the client making the request:

- Queries are read requests. They can read the current state of the Workflow but cannot block in doing so.
- Signals are write requests. They cause changes in the running Workflow, but you cannot await any response or error.
- Updates are interactive write requests, wherein the sender of the Update tracks completion and waits for a response or an error.

## How to choose between Signals, Updates, and Queries? {#choosing-messages}

### For write requests

From the above descriptions, it may sound like Updates can do all the things that Queries and Signals can do. But, unlike Signals, Updates must be synchronous, that is, they must wait for the worker running the Workflow to acknowledge the request.

Use Signals instead of Updates when:

- You want to send a fully asynchronous message.
- Your client does not want to rely on the worker being available.
- Your Workflow’s client cares more about the latency of sending the message than it does of the end-to-end operation.
- When you need to [Signal-With-Start](signal-with-start) atomically start the Workflow and then Signal as the first operation. (since there is currently no Update-with-start operation.)

Use Updates instead of Signals when:

- You want to track the completion of the message from the client.
- You need a result or an exception from your message without having to query subsequently.
- You’d like to “validate” the Update before accepting it into the Workflow and its history.
- Your client cares more about the latency of the end-to-end operation than you care about the latency of sending the message.

### For read requests

You normally want to do a Query:

- Queries are efficient–they never add entries to the [Workflow Event History](/workflows#event-history).
- Queries can operate on completed Workflows.

However, because Queries cannot block, sometimes Updates are best.\
When your goal is to do a read once the Workflow achieves a certain desired state, you have two options.

- You could poll periodically with Queries until the workflow is ready.
- You could write your read operation as an Update, which will give you better efficiency and latency, though it will write an entry to the [Workflow Event History](/workflows#event-history).

## Sending Messages {#sending-messages}

This content will help you write clients that send messages to Workflows.

### Sending Queries

### Sending Signals

You can send Signals from any Temporal Client, the Temporal CLI, or you can Signal one Workflow to another.
You can also "Signal-With-Start" and send a Signal from

#### Send a Signal from a Temporal Client or the CLI

<RelatedReadContainer>
    <RelatedReadItem path="/cli/workflow#signal" text="Send a Signal using the Temporal CLI" archetype="feature-guide" />
    <RelatedReadItem path="/develop/go/message-passing#send-signal-from-client" text="Send Signals with the Go SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/java/message-passing#send-signal-from-client" text="Send Signals with the Java SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/php/message-passing#send-signal-from-client" text="Send Signals with the PHP SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/python/message-passing#send-signal-from-client" text="Send Signals with the Python SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/typescript/message-passing#send-signal-from-client" text="Send Signals with the TypeScript SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/dotnet/message-passing#send-signal-from-client" text="Send Signals with the .NET SDK" archetype="feature-guide" />
</RelatedReadContainer>

#### Send a Signal from one Workflow to another.

<RelatedReadContainer>
    <RelatedReadItem path="/develop/go/message-passing#send-signal-from-workflow" text="Send Signals from Workflows with the Go SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/java/message-passing#send-signal-from-workflow" text="Send Signals from Workflows with the Java SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/php/message-passing#send-signal-from-workflow" text="Send Signals from Workflows with the PHP SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/python/message-passing#send-signal-from-workflow" text="Send Signals from Workflows with the Python SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/typescript/message-passing#send-signal-from-workflow" text="Send Signals from Workflows with the TypeScript SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/dotnet/message-passing#send-signal-from-workflow" text="Send Signals from Workflows with the .NET SDK" archetype="feature-guide" />
</RelatedReadContainer>

#### Signal-With-Start

Signal-With-Start is a great tool for lazily creating workflows. When you send this operation, if there is a running Workflow Execution with the given Workflow Id, it will be Signaled. Otherwise, a new Workflow Execution is started and immediately sent the Signal.

<RelatedReadContainer>
    <RelatedReadItem path="/develop/go/message-passing#signal-with-start" text="Signal-With-Start using the Go SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/java/message-passing#signal-with-start" text="Signal-With-Start using the Java SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/php/message-passing#signal-with-start" text="Signal-With-Start using the PHP SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/python/message-passing#signal-with-start" text="Signal-With-Start using the Python SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/typescript/message-passing#signal-with-start" text="Signal-With-Start using the TypeScript SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/dotnet/message-passing#signal-with-start" text="Signal-With-Start using the .NET SDK" archetype="feature-guide" />
</RelatedReadContainer>

## Sending Queries {#sending-queries}

Queries can be sent from a Temporal Client or the Temporal CLI to a Workflow Execution--even if this workflow has Completed. This call is synchronous and will call into the corresponding Query handler.
You can also send a built-in "Stack Trace Query" for debugging.

<RelatedReadContainer>
    <RelatedReadItem path="/cli/workflow#query" text="Send a Query using the Temporal CLI" archetype="feature-guide" />
    <RelatedReadItem path="/develop/go/message-passing#send-query" text="Send a Query with the Go SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/java/message-passing#send-query" text="Send a Query with the Java SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/php/message-passing#send-query" text="Send a Query with the PHP SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/python/message-passing#send-query" text="Send a Query with the Python SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/typescript/message-passing#send-query" text="Send a Query with the TypeScript SDK" archetype="feature-guide" />
    <RelatedReadItem path="/develop/dotnet/message-passing#send-query" text="Send a Query with the .NET SDK" archetype="feature-guide" />
</RelatedReadContainer>

#### Stack Trace Query {#stack-trace-query}

In many SDKs, the Temporal Client exposes a predefined `__stack_trace` Query that returns the call stack of all the threads owned by that Workflow Execution.
This is a great way to troubleshoot a Workflow Execution in production.
For example, if a Workflow Execution has been stuck at a state for longer than an expected period of time, you can send a `__stack_trace` Query to return the current call stack.
The `__stack_trace` Query name does not require special handling in your Workflow code.

:::note

Stack Trace Queries are available only for running Workflow Executions.

:::

## Updates {#updates}

**What is an Update in the context of Temporal?**

:::tip Support, stability, and dependency info

- In [Pre-release](/evaluate/development-production-features/release-stages#pre-release) (API is subject to change)
- Introduced in [Temporal Server version 1.21](https://github.com/temporalio/temporal/releases/tag/v1.21.0)
- Available in [Go SDK](https://pkg.go.dev/go.temporal.io/sdk@v1.23.1/client#Client.UpdateWorkflowWithOptions) since [v1.23.0](https://github.com/temporalio/sdk-go/releases/tag/v1.23.0)
- Available in [Java SDK](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowStub.html#startUpdate(io.temporal.client.UpdateOptions,java.lang.Object...)) since [v1.20.0](https://github.com/temporalio/sdk-java/releases/tag/v1.20.0)
- Available in [Python SDK](https://docs.temporal.io/develop/python/features#updates) since [v1.4.0](https://github.com/temporalio/sdk-python/releases/tag/1.4.0)
- Available in [.NET SDK](https://dotnet.temporal.io/api/Temporalio.Client.WorkflowHandle.html#Temporalio_Client_WorkflowHandle_ExecuteUpdateAsync_System_String_System_Collections_Generic_IReadOnlyCollection_System_Object__Temporalio_Client_WorkflowUpdateOptions_) since [v0.1.0-beta2](https://github.com/temporalio/sdk-dotnet/releases/tag/0.1.0-beta2)
- Available in [TypeScript SDK](https://typescript.temporal.io/api/interfaces/client.WorkflowHandle#executeupdate) since [v1.9.0](https://github.com/temporalio/sdk-typescript/releases/tag/v1.9.0)
- Available in [PHP SDK](https://php.temporal.io/classes/Temporal-Client-WorkflowStubInterface.html#method_startUpdate) since [v2.8.0](https://github.com/temporalio/sdk-php/releases/tag/v2.8.0)

:::

An Update is a request and response from a Temporal Client to a [Workflow Execution](/workflows#workflow-execution).

<RelatedReadContainer>
    <RelatedReadItem path="/develop/go/message-passing#updates" text="Develop, send, and handle Updates in Go" archetype="feature-guide" />
    <RelatedReadItem path="/develop/java/message-passing#updates" text="Develop, send, and handle Updates in Java" archetype="feature-guide" />
    <RelatedReadItem path="/develop/php/message-passing#updates" text="Develop, send, and handle Updates in PHP" archetype="feature-guide" />
    <RelatedReadItem path="/develop/python/message-passing#updates" text="Develop, send, and handle Updates in Python" archetype="feature-guide" />
    <RelatedReadItem path="/develop/dotnet/message-passing#updates" text="Develop, send, and handle Updates in .NET" archetype="feature-guide" />
</RelatedReadContainer>

You can think of an Update as a synchronous, blocking call that could replace both a Signal and a Query. An update is:

- A Signal that can return a value, and has lower overhead and latency
- A Query that can mutate workflow state

The Workflow must have a function to handle the Update.
The Update handler can mutate workflow state (like a [Signal](#signals) but unlike a [Query](#queries)) and return a value to the caller (like a Query but unlike a Signal).
Like every bit of code in a Workflow, Update handlers must be [deterministic](/workflows#deterministic-constraints).
However, they may use all the available Workflow features, such as executing Activities and child Workflows, and waiting on timers/conditions.

To avoid losing Updates when using [Continue-As-New](/workflows#continue-as-new), ensure that all Update handlers have completed before calling Continue-As-New.

When there is the potential for multiple Updates to cause a duplication problem, Temporal recommends adding idempotency logic to your Update handler that checks for duplicates.

An Update has four phases.

1. **Admission.** The Temporal Service first validates Update submissions against the configured resource usage limits.
   For example, limits apply to concurrent requests and requests per second.
   For more details, see the [Temporal Platform defaults](/self-hosted-guide/defaults).
   When this phase is complete, the Platform changes the status of the Update to **Admitted**.
   At this stage, the Platform hasn't yet persisted the Update to the Workflow Execution's Event History or sent it to a Worker.
2. **Validation.** An optional developer-provided function that performs request validation.
   This validation code, similar to a [Query](#queries) handler, can observe but not change the Workflow state.
   This means that the validation of an Update request may depend on the Workflow state at runtime.
   To indicate that the Update request doesn't pass validation, the validation code must throw/return a language-appropriate error.
   In this case, the system rejects the request, doesn't record anything in the Workflow Event History to indicate that the Update ever happened, and the Update processing doesn't proceed to later phases.
   If the Update completes the validation stage without error, the Platform changes its state to **Accepted** and a [WorkflowExecutionUpdateAcceptedEvent](/references/events#workflowexecutionupdateacceptedevent) Event is added to Workflow Execution [Event History](/workflows#event-history).
3. **Execution.** Accepted Update requests move to the execution phase.
   In this phase, the Worker delivers the request to the Update handler.
4. **Completion.** The Update handler can return a result or a language-appropriate error/exception to indicate its completion.
   The Platform sends the Update outcome back to the original invoking entity as an Update response.
   A [WorkflowExecutionUpdateCompletedEvent](/references/events#workflowexecutionupdatecompletedevent) Event in the Workflow Execution Event History denotes the completion of an Update.

:::note

Workflow Updates are currently disabled by default on Temporal Server.

To enable the `UpdateWorkflowExecution` API, set the [frontend.enableUpdateWorkflowExecution](https://github.com/temporalio/temporal/blob/main/common/dynamicconfig/constants.go) dynamic config value to `true`.

For example, to enable Workflow Updates with the Temporal CLI, pass the value when executing the Temporal CLI command:

```command
temporal server start-dev --dynamic-config-value frontend.enableUpdateWorkflowExecution=true
```

:::
